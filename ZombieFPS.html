<!DOCTYPE html>
<html>
<head>
<title>Minecraft Open World FPS - Remastered</title>
<meta charset="utf-8"/>
<style>
/* --- ORIGINAL CSS RETAINED & IMPROVED --- */
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #0a0a0a; font-family: 'Courier New', monospace; cursor: none; }
canvas { cursor: none; display: block; }

#hudTop { position: fixed; top: 10px; left: 10px; right: 10px; color: #0f0; font-size: 11px; background: rgba(0,0,0,.6); padding: 8px; border: 1px solid #0f0; border-radius: 4px; text-align: center; backdrop-filter: blur(5px); }
#timeInfo { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #0f0; background: rgba(0,0,0,.6); padding: 8px 20px; border: 1px solid #0f0; border-radius: 4px; font-size: 11px; backdrop-filter: blur(5px); }

#crosshair { position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%); width: 40px; height: 40px; pointer-events: none; }
.crosshairLine { position: absolute; background: #0f0; box-shadow: 0 0 4px #0f0; }
.crosshairH { width: 12px; height: 2px; left: 14px; top: 50%; transform: translateY(-50%); }
.crosshairV { width: 2px; height: 12px; top: 14px; left: 50%; transform: translateX(-50%); }

#gunHud { position: fixed; bottom: 20px; right: 20px; color: #0f0; background: linear-gradient(45deg, rgba(0,0,0,0.9), rgba(0,20,0,0.7)); padding: 15px; border: 1px solid #0f0; border-radius: 8px; font-size: 12px; min-width: 220px; box-shadow: 0 0 10px rgba(0,255,0,0.2); }
#weaponName { font-size: 18px; font-weight: bold; margin-bottom: 8px; color: #ffff00; text-shadow: 1px 1px 0 #000; }
#ammoDisplay { margin: 6px 0; padding: 6px 0; border-top: 1px solid #0f0; border-bottom: 1px solid #0f0; }

#hudBottom { position: fixed; bottom: 20px; left: 20px; color: #0f0; font-size: 12px; background: rgba(0,0,0,.6); padding: 12px; border: 1px solid #0f0; border-radius: 4px; width: 280px; backdrop-filter: blur(5px); }

#minimap { position: fixed; top: 80px; right: 20px; width: 160px; height: 160px; background: rgba(0,0,0,0.8); border: 2px solid #0f0; border-radius: 4px; overflow: hidden; opacity: 0.9; }

#killFeed { position: fixed; top: 120px; right: 20px; color: #ff6b6b; font-size: 11px; max-width: 280px; z-index: 5; }
.killFeedItem { background: rgba(0,0,0,.7); padding: 5px 8px; margin: 2px 0; border-left: 3px solid #ff6b6b; animation: fadeOut 3s forwards; }
@keyframes fadeOut { 0% { opacity: 1; transform: translateX(0); } 85% { opacity: 1; } 100% { opacity: 0; transform: translateX(20px); } }

#status { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); color: #fff; background: rgba(0,0,0,.8); padding: 10px 20px; border: 1px solid #fff; border-radius: 20px; font-size: 14px; font-weight: bold; display: none; box-shadow: 0 0 15px rgba(255,255,255,0.2); }
#location { position: fixed; bottom: 10px; right: 20px; color: #0f0; background: rgba(0,0,0,.8); padding: 6px 12px; border: 1px solid #0f0; border-radius: 3px; font-size: 10px; }

#escMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,.95); display: none; z-index: 2000; overflow-y: auto; padding: 40px; }
#escMenu.visible { display: block; }
#escMenuContent { max-width: 900px; margin: 0 auto; color: #0f0; }
.menuSection { background: rgba(0,20,0,.8); border: 1px solid #0f0; padding: 20px; margin: 20px 0; border-radius: 4px; }
.menuSection h2 { border-bottom: 1px solid #0f0; padding-bottom: 10px; margin-bottom: 15px; font-size: 18px; }
.menuRow { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 10px 0; padding: 8px 0; border-bottom: 1px solid #1a3a1a; }
.inventoryItem { background: rgba(0,40,0,.6); border: 1px solid #0a8; padding: 10px; margin: 8px 0; border-radius: 3px; font-size: 11px; }
#closeMenuBtn, .menuBtn { margin-top: 10px; margin-right: 10px; padding: 10px 20px; background: #0f0; color: #000; border: none; border-radius: 3px; cursor: pointer; font-weight: bold; }
#closeMenuBtn:hover, .menuBtn:hover { background: #0a8; }
.btnGroup { display: flex; gap: 10px; flex-wrap: wrap; margin: 20px 0; }

/* Rarity colors */
.rarity-common { color: #888; }
.rarity-uncommon { color: #2d5016; }
.rarity-rare { color: #0a8; }
.rarity-epic { color: #a0f; }
.rarity-legendary { color: #ff8800; }
</style>
</head>
<body>

<div id="timeInfo">üåç TIME: <span id="timeDisplay">6:00</span> | <span id="weatherDisplay">Day</span></div>
<div id="hudTop">K/D: <span id="kdRatio">0/0</span> | Score: <span id="scoreDisplay">0</span> | Kills: <span id="kills">0</span> | Headshots: <span id="headshots">0</span></div>

<div id="crosshair">
  <div class="crosshairLine crosshairH"></div>
  <div class="crosshairLine crosshairV"></div>
</div>

<div id="minimap"></div>

<div id="gunHud">
  <div id="weaponName">PISTOL</div>
  <div id="ammoDisplay">
    <div>Current: <span id="magAmmo">30</span></div>
    <div>Reserve: <span id="totalAmmo">90</span></div>
    <div style="font-size: 10px; color: #888; margin-top: 4px;">E = Pickup | ESC = Menu</div>
  </div>
</div>

<div id="hudBottom">
  <div style="border-bottom: 1px solid #0f0; margin-bottom: 8px; padding-bottom: 8px;">
    <div>‚ù§ Health: <span id="health">100</span>/100</div>
    <div>üõ° Armor: <span id="armor">0</span>/100</div>
  </div>
  <div style="font-size: 10px; color: #888; margin-top: 8px;">
    <div>WASD=Move | Space=Jump | Shift=Sprint | Ctrl=Crouch</div>
    <div>Mouse=Aim | Click=Shoot | R=Reload | Q=Drop Gun</div>
  </div>
</div>

<div id="killFeed"></div>
<div id="status"></div>
<div id="location">üìç Spawn (0,0)</div>

<div id="escMenu">
  <div id="escMenuContent">
    <h1 style="color: #0f0; margin-bottom: 20px; border-bottom: 2px solid #0f0; padding-bottom: 10px;">‚öô GAME PAUSED - Press ESC to Resume</h1>
    
    <div style="background: rgba(0,60,0,.6); border: 1px solid #0f0; padding: 15px; margin: 20px 0; border-radius: 4px;">
      <div class="btnGroup">
        <button id="saveBtn" class="menuBtn">üíæ SAVE GAME</button>
        <button id="loadBtn" class="menuBtn">üìÇ LOAD GAME</button>
        <button id="closeMenuBtn">‚ñ∂ RESUME GAME (ESC)</button>
      </div>
    </div>
    
    <div class="menuSection">
      <h2>üìä STATS</h2>
      <div class="menuRow">
        <div><span style="color: #888;">Kills:</span> <span style="color: #0f0; font-weight: bold;" id="statKills">0</span></div>
        <div><span style="color: #888;">Deaths:</span> <span style="color: #0f0; font-weight: bold;" id="statDeaths">0</span></div>
      </div>
      <div class="menuRow">
        <div><span style="color: #888;">Headshots:</span> <span style="color: #0f0; font-weight: bold;" id="statHeadshots">0</span></div>
        <div><span style="color: #888;">K/D Ratio:</span> <span style="color: #0f0; font-weight: bold;" id="statKD">0.00</span></div>
      </div>
      <div class="menuRow">
        <div><span style="color: #888;">Score:</span> <span style="color: #0f0; font-weight: bold;" id="statScore">0</span></div>
        <div><span style="color: #888;">Accuracy:</span> <span style="color: #0f0; font-weight: bold;" id="statAccuracy">0%</span></div>
      </div>
    </div>

    <div class="menuSection">
      <h2>üî´ CURRENT WEAPON</h2>
      <div class="inventoryItem">
        <div style="color: #ffff00; font-weight: bold;" id="menuWeaponName">PISTOL</div>
        <div style="font-size: 11px; color: #0f0; margin-top: 5px;">Mag: <span id="menuMagAmmo">0</span> | Reserve: <span id="menuReserveAmmo">0</span></div>
        <div style="font-size: 10px; color: #888; margin-top: 5px;" id="menuWeaponStats">DMG: 0 | Fire Rate: 0</div>
      </div>
    </div>

    <div class="menuSection">
      <h2>üìç LOCATION</h2>
      <div class="menuRow">
        <div><span style="color: #888;">X Position:</span> <span style="color: #0f0; font-weight: bold;" id="menuPosX">0</span></div>
        <div><span style="color: #888;">Z Position:</span> <span style="color: #0f0; font-weight: bold;" id="menuPosZ">0</span></div>
      </div>
      <div class="menuRow">
        <div><span style="color: #888;">Biome:</span> <span style="color: #0f0; font-weight: bold;" id="menuBiome">Plains</span></div>
        <div><span style="color: #888;">Height:</span> <span style="color: #0f0; font-weight: bold;" id="menuHeight">0m</span></div>
      </div>
      <div style="margin-top: 15px;">
        <span style="color: #888;">Nearby Weapons:</span> <span style="color: #f0f; font-weight: bold;" id="nearbyWeapons">None</span>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>

<script>
/* =============== HELPER: TEXTURE GENERATION =============== */
// Procedural textures for better graphics
function generateTexture(colorHex, noiseAmount) {
  const size = 512;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  
  // Base color
  ctx.fillStyle = colorHex;
  ctx.fillRect(0,0,size,size);
  
  // Noise
  for(let i=0; i<40000; i++) {
    const x = Math.random() * size;
    const y = Math.random() * size;
    const w = Math.random() * 3 + 1;
    const shade = (Math.random() - 0.5) * noiseAmount;
    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
    if (Math.random() > 0.5) ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.2})`;
    ctx.fillRect(x,y,w,w);
  }
  
  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = THREE.RepeatWrapping;
  tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

const textures = {
  grass: generateTexture('#2d5a27', 0.5),
  dirt: generateTexture('#5d4037', 0.6),
  snow: generateTexture('#e0e0e0', 0.3),
  sand: generateTexture('#e6c288', 0.4),
  stone: generateTexture('#757575', 0.6)
};

/* =============== AUDIO SYSTEM =============== */
let audioContext = null;

function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(frequency, duration, volume = 0.3, waveType = 'sine') {
  if (!audioContext) initAudio();
  const now = audioContext.currentTime;
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  
  osc.connect(gain);
  gain.connect(audioContext.destination);
  
  osc.type = waveType;
  osc.frequency.setValueAtTime(frequency, now);
  gain.gain.setValueAtTime(volume, now);
  gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
  
  osc.start(now);
  osc.stop(now + duration);
}

function playShotSound() {
  playSound(150, 0.08, 0.4, 'square');
  playSound(100, 0.1, 0.3, 'sawtooth');
}

function playEnemySound() {
  const freq = 50 + Math.random() * 100;
  playSound(freq, 0.2, 0.25, 'sawtooth');
}

function playEnemyHitSound() {
  playSound(200, 0.05, 0.3, 'sine');
}

/* =============== CONFIG =============== */
const CONFIG = {
  sensitivity: 0.0025,
  sprintSpeed: 14, // Slightly faster for fun
  walkSpeed: 8,
  crouchSpeed: 4,
  jumpPower: 18,
  gravity: -38,
  friction: 0.85,
  mapSize: 2000, // Bigger map
};

/* =============== GAME STATE =============== */
const gameState = {
  health: 100,
  maxHealth: 100,
  armor: 0,
  maxArmor: 100,
  kills: 0,
  headshots: 0,
  deaths: 0,
  shots: 0,
  hits: 0,
  score: 0,
  multiplier: 1,
  paused: false,
  gameTime: 6, 
  gameSpeed: 0.0001,
};

let currentWeapon = 0;
let lastShotTime = 0;
let inventory = [];
let waveCount = 0;
let lastWaveTime = 0;

/* =============== RARITY SYSTEM =============== */
const rarities = {
  common: { name: "COMMON", color: 0x888888, chance: 0.45 },
  uncommon: { name: "UNCOMMON", color: 0x2d5016, chance: 0.30 },
  rare: { name: "RARE", color: 0x00aaff, chance: 0.15 },
  epic: { name: "EPIC", color: 0xaa00ff, chance: 0.08 },
  legendary: { name: "LEGENDARY", color: 0xffaa00, chance: 0.02 },
};

/* =============== WEAPON SYSTEM =============== */
const weaponTypes = {
  // Valorant Weapons
  classic: { name: "CLASSIC", damage: 24, fireRate: 12, magSize: 30, spread: 0.6, recoil: 1.8, color: 0x888888, game: "Valorant", type: "pistol" },
  phantom: { name: "PHANTOM", damage: 39, fireRate: 9, magSize: 30, spread: 0.5, recoil: 1.5, color: 0x00aa00, game: "Valorant", type: "rifle" },
  vandal: { name: "VANDAL", damage: 40, fireRate: 9, magSize: 25, spread: 0.4, recoil: 2, color: 0x0088ff, game: "Valorant", type: "rifle" },
  // CS:GO Weapons
  ak47: { name: "AK-47", damage: 36, fireRate: 10, magSize: 30, spread: 0.7, recoil: 2.2, color: 0xff3333, game: "CSGO", type: "rifle" },
  m4a4: { name: "M4A4", damage: 21, fireRate: 13, magSize: 30, spread: 0.6, recoil: 1.4, color: 0x33ff33, game: "CSGO", type: "rifle" },
  awp: { name: "AWP", damage: 115, fireRate: 1.4, magSize: 10, spread: 0.01, recoil: 4, color: 0x444444, game: "CSGO", type: "sniper" },
  // Fortnite Weapons
  ar: { name: "ASSAULT RIFLE", damage: 28, fireRate: 11, magSize: 30, spread: 0.8, recoil: 1.6, color: 0xffaa00, game: "Fortnite", type: "rifle" },
  shotgun_fort: { name: "COMBAT SHOTGUN", damage: 68, fireRate: 1.8, magSize: 8, spread: 4, recoil: 4.5, color: 0xff6600, game: "Fortnite", type: "shotgun" },
  sniper_fort: { name: "BOLT SNIPER", damage: 105, fireRate: 1.2, magSize: 5, spread: 0.05, recoil: 3.5, color: 0x444444, game: "Fortnite", type: "sniper" },
  // Minecraft Style
  wooden_sword: { name: "DIAMOND SWORD", damage: 45, fireRate: 2, magSize: 1, spread: 0.2, recoil: 1, color: 0x00ffff, game: "Minecraft", type: "melee" },
  // Halo Weapons
  energy_sword: { name: "ENERGY SWORD", damage: 85, fireRate: 3, magSize: 1, spread: 0, recoil: 2, color: 0xff00ff, game: "Halo", type: "melee_energy" },
};

let weapons = [
  { ...weaponTypes.classic, mag: 30, totalAmmo: 90, rarity: "common" },
  { ...weaponTypes.ak47, mag: 30, totalAmmo: 90, rarity: "uncommon" },
  { ...weaponTypes.awp, mag: 10, totalAmmo: 30, rarity: "epic" }
];

/* =============== THREE.JS SETUP =============== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 200, 1500); // Improved Fog

const camera = new THREE.PerspectiveCamera(85, innerWidth / innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true, precision: 'highp' });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true; // Enabled Shadows
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
document.body.appendChild(renderer.domElement);

/* =============== PHYSICS VARIABLES =============== */
const spawnPos = findSpawnLocation();
const player = {
  pos: spawnPos.clone(),
  vel: new THREE.Vector3(0, 0, 0),
  isGrounded: false,
  height: 1.8,
  inSafeZone: false,
};

const cameraState = {
  pitch: 0,
  yaw: 0,
  targetPitch: 0,
  targetYaw: 0,
  bobTime: 0 // For weapon bobbing physics
};

/* =============== GUN RENDERING (IMPROVED) =============== */
let gunModel = null;
let gunGroup = new THREE.Group();
let muzzleFlash = null;
scene.add(gunGroup);

function createMuzzleFlash() {
  if (muzzleFlash) scene.remove(muzzleFlash);
  const flashGeometry = new THREE.SphereGeometry(0.2, 8, 8);
  const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
  muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);
  return muzzleFlash;
}

function showMuzzleFlash() {
  if (!muzzleFlash) muzzleFlash = createMuzzleFlash();
  const gunPos = gunModel.position.clone();
  muzzleFlash.position.set(0.2, 0.1, -1.5); // Relative to camera/gun group
  gunGroup.add(muzzleFlash);
  setTimeout(() => gunGroup.remove(muzzleFlash), 50);
}

// Procedural Gun Generator based on Weapon Type
function createGunModel(weaponData) {
  if (gunModel) gunGroup.remove(gunModel);
  gunModel = new THREE.Group();

  const primaryColor = weaponData.color;
  const metalMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.8 });
  const skinMat = new THREE.MeshStandardMaterial({ color: primaryColor, roughness: 0.4, metalness: 0.4 });
  const glowMat = new THREE.MeshBasicMaterial({ color: primaryColor });

  if (weaponData.type === 'melee' || weaponData.type === 'melee_energy') {
      // SWORD MODEL
      const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.6), metalMat);
      handle.position.set(0.4, -0.4, -0.5);
      gunModel.add(handle);

      const guard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.1), metalMat);
      guard.position.set(0.4, -0.4, -0.8);
      gunModel.add(guard);

      const bladeGeo = new THREE.BoxGeometry(0.1, 0.05, 1.5);
      const bladeMat = weaponData.type === 'melee_energy' ? glowMat : skinMat;
      const blade = new THREE.Mesh(bladeGeo, bladeMat);
      blade.position.set(0.4, -0.4, -1.6);
      gunModel.add(blade);
      
      // Halo Sword shape tweak
      if (weaponData.type === 'melee_energy') {
          const blade2 = blade.clone();
          blade.position.x += 0.1;
          blade2.position.x -= 0.1; 
          blade.rotation.z = 0.1;
          blade2.rotation.z = -0.1;
          gunModel.add(blade2);
      }

  } else if (weaponData.type === 'pistol') {
      // PISTOL MODEL
      const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.6), metalMat);
      barrel.position.set(0.3, -0.3, -0.8);
      gunModel.add(barrel);
      
      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.4, 0.15), skinMat);
      grip.position.set(0.3, -0.5, -0.6);
      grip.rotation.x = 0.2;
      gunModel.add(grip);

  } else if (weaponData.type === 'sniper') {
      // SNIPER MODEL
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), metalMat);
      barrel.rotation.x = Math.PI / 2;
      barrel.position.set(0.3, -0.25, -1.5);
      gunModel.add(barrel);

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 0.8), skinMat);
      body.position.set(0.3, -0.25, -0.5);
      gunModel.add(body);

      const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.07, 0.5, 8), new THREE.MeshStandardMaterial({color: 0x111111}));
      scope.rotation.x = Math.PI/2;
      scope.position.set(0.3, 0, -0.5);
      gunModel.add(scope);

  } else {
      // RIFLE MODEL
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.5, 8), metalMat);
      barrel.rotation.x = Math.PI / 2;
      barrel.position.set(0.3, -0.25, -1.2);
      gunModel.add(barrel);

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 1.0), skinMat);
      body.position.set(0.3, -0.3, -0.5);
      gunModel.add(body);

      const mag = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.25), new THREE.MeshStandardMaterial({color: 0x111111}));
      mag.position.set(0.3, -0.6, -0.4);
      mag.rotation.x = 0.3;
      gunModel.add(mag);
  }

  // Common scaling
  gunModel.position.set(0.2, -0.2, -0.5);
  gunGroup.add(gunModel);
}

function updateGunView(dt) {
  if (gunGroup) {
    gunGroup.position.copy(camera.position);
    gunGroup.rotation.copy(camera.rotation);

    // Physics: Weapon Bobbing
    const isMoving = (Math.abs(player.vel.x) > 1 || Math.abs(player.vel.z) > 1);
    if (isMoving && player.isGrounded) {
        cameraState.bobTime += dt * 10;
        const bobX = Math.cos(cameraState.bobTime) * 0.02;
        const bobY = Math.sin(cameraState.bobTime * 2) * 0.02;
        gunModel.position.x = 0.2 + bobX;
        gunModel.position.y = -0.2 + bobY;
    } else {
        // Return to center
        gunModel.position.x += (0.2 - gunModel.position.x) * 0.1;
        gunModel.position.y += (-0.2 - gunModel.position.y) * 0.1;
    }
  }
}

/* =============== NOISE & TERRAIN =============== */
function perlin(x, y, seed = 0) {
  // Simple pseudo-random noise
  return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1;
}

function smoothstep(t) { return t * t * (3 - 2 * t); }

function perlinNoise(x, y) {
   // Improved noise function approximation for better terrain
   const X = Math.floor(x);
   const Y = Math.floor(y);
   const xf = x - X;
   const yf = y - Y;
   
   const tl = Math.sin(X*127.1 + Y*311.7) * 43758.5453123 % 1;
   const tr = Math.sin((X+1)*127.1 + Y*311.7) * 43758.5453123 % 1;
   const bl = Math.sin(X*127.1 + (Y+1)*311.7) * 43758.5453123 % 1;
   const br = Math.sin((X+1)*127.1 + (Y+1)*311.7) * 43758.5453123 % 1;
   
   const u = smoothstep(xf);
   const v = smoothstep(yf);
   
   const top = tl + (tr - tl) * u;
   const bot = bl + (br - bl) * u;
   return top + (bot - top) * v;
}

function getTerrainHeight(x, z) {
  // Layered noise for better mountains
  let height = 0;
  height += perlinNoise(x * 0.003, z * 0.003) * 60; // Big mountains
  height += perlinNoise(x * 0.01, z * 0.01) * 15;  // Hills
  height += perlinNoise(x * 0.05, z * 0.05) * 2;   // Bumps
  
  // Flatten center spawn area slightly
  const dist = Math.sqrt(x*x + z*z);
  if (dist < 100) height *= (dist/100);
  
  return Math.max(5, height + 20); // Base height
}

function getBiome(y) {
    if (y > 70) return "snow";
    if (y > 40) return "stone";
    if (y < 12) return "sand";
    return "grass";
}

function findSpawnLocation() {
  return new THREE.Vector3(0, getTerrainHeight(0,0) + 5, 0);
}

/* =============== TERRAIN GENERATION (FIXED & TEXTURED) =============== */
function generateTerrain() {
  const gridSize = 100;
  const gridSpacing = 30; // Scale
  const geometry = new THREE.PlaneGeometry(gridSize * gridSpacing, gridSize * gridSpacing, gridSize, gridSize);
  geometry.rotateX(-Math.PI / 2);

  const posAttribute = geometry.attributes.position;
  const colors = [];
  const uvs = geometry.attributes.uv;

  for (let i = 0; i < posAttribute.count; i++) {
    const x = posAttribute.getX(i);
    const z = posAttribute.getZ(i);
    const y = getTerrainHeight(x, z);
    posAttribute.setY(i, y);
    
    // Vertex coloring based on height (Biome)
    const biome = getBiome(y);
    let color = new THREE.Color(0x5a8a2a); // Default grass
    if (biome === 'snow') color.setHex(0xffffff);
    else if (biome === 'stone') color.setHex(0x757575);
    else if (biome === 'sand') color.setHex(0xe6c288);
    
    // Add noise variation to color
    color.r += (Math.random()-0.5)*0.05;
    color.g += (Math.random()-0.5)*0.05;
    color.b += (Math.random()-0.5)*0.05;
    
    colors.push(color.r, color.g, color.b);
  }

  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  // Use a material that supports vertex colors AND shadows
  const material = new THREE.MeshStandardMaterial({ 
    vertexColors: true,
    roughness: 0.8,
    metalness: 0.1,
  });
  
  const terrain = new THREE.Mesh(geometry, material);
  terrain.castShadow = true;
  terrain.receiveShadow = true;
  scene.add(terrain);
  
  // Water plane
  const waterGeo = new THREE.PlaneGeometry(CONFIG.mapSize * 2, CONFIG.mapSize * 2);
  const waterMat = new THREE.MeshStandardMaterial({ color: 0x224488, transparent: true, opacity: 0.6, roughness: 0.1 });
  const water = new THREE.Mesh(waterGeo, waterMat);
  water.rotation.x = -Math.PI/2;
  water.position.y = 10;
  scene.add(water);
}

generateTerrain();

/* =============== LIGHTING (IMPROVED) =============== */
function updateLighting() {
  // Remove old lights
  scene.children.forEach(c => {
      if (c.isLight) scene.remove(c);
  });

  const time = gameState.gameTime;
  let sunIntensity = Math.sin((time / 24) * Math.PI) * 1.5;
  if (sunIntensity < 0) sunIntensity = 0;

  // Sky color
  const skyColor = new THREE.Color(0x87ceeb).lerp(new THREE.Color(0x050510), 1 - (sunIntensity/1.5));
  scene.background = skyColor;
  scene.fog.color = skyColor;

  // Sun (Directional)
  const sunLight = new THREE.DirectionalLight(0xffffff, sunIntensity);
  sunLight.position.set(100, 200, 50);
  sunLight.castShadow = true;
  
  // Shadow properties for better quality
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 500;
  sunLight.shadow.bias = -0.001;
  const d = 200;
  sunLight.shadow.camera.left = -d;
  sunLight.shadow.camera.right = d;
  sunLight.shadow.camera.top = d;
  sunLight.shadow.camera.bottom = -d;
  scene.add(sunLight);

  // Ambient (Hemisphere for nice gradients)
  const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x2d5a27, 0.4);
  scene.add(hemiLight);
}
updateLighting();

/* =============== PARTICLES (IMPACTS) =============== */
const particles = [];
function createImpact(pos, color) {
    for(let i=0; i<8; i++) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({color: color}));
        mesh.position.copy(pos);
        // Random velocity
        const vel = new THREE.Vector3((Math.random()-0.5)*10, Math.random()*10, (Math.random()-0.5)*10);
        particles.push({ mesh, vel, life: 1.0 });
        scene.add(mesh);
    }
}

function updateParticles(dt) {
    for(let i = particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.life -= dt * 2;
        p.vel.y -= 20 * dt; // Gravity
        p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
        p.mesh.scale.setScalar(p.life);
        
        if(p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

/* =============== SAFE ZONES =============== */
class SafeZone {
  constructor(x, z) {
    this.pos = new THREE.Vector3(x, getTerrainHeight(x, z), z);
    this.radius = 35;
    
    // Glowing dome
    const geometry = new THREE.SphereGeometry(this.radius, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.5);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);
  }
  isPlayerInZone(playerPos) { return this.pos.distanceTo(playerPos) < this.radius; }
  isEnemyInZone(enemyPos) { return this.pos.distanceTo(enemyPos) < this.radius; }
}

const safeZones = [];
function spawnSafeZones() {
    for(let i=0; i<3; i++) {
        safeZones.push(new SafeZone((Math.random()-0.5)*800, (Math.random()-0.5)*800));
    }
}

/* =============== ENEMIES (IMPROVED MODELS) =============== */
class Enemy {
  constructor(x, z, type = 'zombie') {
    this.type = type;
    this.pos = new THREE.Vector3(x, getTerrainHeight(x, z) + 1, z);
    this.vel = new THREE.Vector3(0, 0, 0);
    const config = { 
        zombie: { hp: 80, speed: 4, damage: 12, color: 0x5d7c3a },
        demon: { hp: 150, speed: 6, damage: 20, color: 0x8b3a3a },
        tank: { hp: 250, speed: 2, damage: 30, color: 0x333333} 
    };
    Object.assign(this, config[type]);
    this.maxHp = this.hp;

    // COMPOUND MESH FOR ANIMATION
    this.mesh = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.8 });
    
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mat);
    head.position.y = 1.6;
    head.castShadow = true;
    this.mesh.add(head);
    
    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), mat);
    body.position.y = 0.9;
    body.castShadow = true;
    this.mesh.add(body);
    
    // Arms (Independent for animation)
    this.armL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
    this.armL.position.set(-0.4, 1.0, 0.2);
    this.mesh.add(this.armL);
    
    this.armR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
    this.armR.position.set(0.4, 1.0, 0.2);
    this.mesh.add(this.armR);

    // Legs
    this.legL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), mat);
    this.legL.position.set(-0.2, 0.4, 0);
    this.mesh.add(this.legL);

    this.legR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), mat);
    this.legR.position.set(0.2, 0.4, 0);
    this.mesh.add(this.legR);

    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);
    this.walkTime = 0;
    this.attackCooldown = 0;
  }

  update(playerPos, dt) {
    this.vel.y -= 35 * dt;
    this.pos.add(this.vel.clone().multiplyScalar(dt));
    const groundHeight = getTerrainHeight(this.pos.x, this.pos.z);
    if (this.pos.y <= groundHeight) {
      this.pos.y = groundHeight;
      this.vel.y = 0;
    }

    const dirToPlayer = new THREE.Vector3().subVectors(playerPos, this.pos).normalize();
    const moveDir = dirToPlayer.clone().multiplyScalar(this.speed);
    
    // Only move if not too close
    if (this.pos.distanceTo(playerPos) > 1.5) {
        this.pos.x += moveDir.x * dt;
        this.pos.z += moveDir.z * dt;
        
        // Animation
        this.walkTime += dt * 10;
        this.legL.rotation.x = Math.sin(this.walkTime) * 0.5;
        this.legR.rotation.x = Math.cos(this.walkTime) * 0.5;
        this.armL.rotation.x = -1.5 + Math.cos(this.walkTime) * 0.3; // Zombie arms
        this.armR.rotation.x = -1.5 + Math.sin(this.walkTime) * 0.3;
    }

    this.mesh.position.copy(this.pos);
    this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);

    this.attackCooldown = Math.max(0, this.attackCooldown - dt);
    const distToPlayer = this.pos.distanceTo(playerPos);
    if (distToPlayer < 2 && this.attackCooldown <= 0) {
      gameState.health -= this.damage;
      this.attackCooldown = 1.5;
      playEnemySound();
      // Visual damage on player
      document.body.style.boxShadow = "inset 0 0 50px red";
      setTimeout(() => document.body.style.boxShadow = "none", 100);
    }
  }

  takeDamage(dmg) {
    this.hp -= dmg;
    // Flash Red
    this.mesh.children.forEach(c => {
        if(c.material) {
            const old = c.material.color.getHex();
            c.material.color.setHex(0xff0000);
            setTimeout(() => c.material.color.setHex(old), 50);
        }
    });
    createImpact(this.pos.clone().add(new THREE.Vector3(0,1.5,0)), 0xff0000); // Blood effect
  }

  isAlive() { return this.hp > 0; }
}

let enemies = [];
function spawnWave() {
  waveCount++;
  const count = 5 + waveCount * 2;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 100 + Math.random() * 100;
    const x = player.pos.x + Math.cos(angle) * dist;
    const z = player.pos.z + Math.sin(angle) * dist;
    
    let type = 'zombie';
    if (waveCount > 2 && Math.random() < 0.3) type = 'demon';
    if (waveCount > 4 && Math.random() < 0.2) type = 'tank';
    enemies.push(new Enemy(x, z, type));
  }
}

/* =============== GUN MECHANICS =============== */
function shoot() {
  const weapon = weapons[currentWeapon];
  if (weapon.mag <= 0) {
      showStatus("RELOAD!");
      return;
  }
  const now = Date.now();
  const fireRateMs = 1000 / weapon.fireRate;
  if (now - lastShotTime < fireRateMs) return;

  lastShotTime = now;
  weapon.mag--;
  gameState.shots++;

  playShotSound();
  showMuzzleFlash();

  // Recoil
  cameraState.targetPitch += weapon.recoil * 0.01;
  cameraState.targetYaw += (Math.random()-0.5) * weapon.recoil * 0.01;

  // Melee vs Gun logic
  if (weapon.type && weapon.type.includes('melee')) {
      // Short range box check
      const hit = enemies.find(e => e.pos.distanceTo(player.pos) < 4);
      if(hit) {
          hit.takeDamage(weapon.damage);
          playEnemyHitSound();
          if(!hit.isAlive()) handleKill(hit);
      }
      return;
  }

  // Raycasting for guns
  const raycaster = new THREE.Raycaster();
  const direction = new THREE.Vector3(0, 0, -1)
    .applyAxisAngle(new THREE.Vector3(1, 0, 0), cameraState.pitch)
    .applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.yaw);

  // Spread
  direction.x += (Math.random() - 0.5) * weapon.spread * 0.01;
  direction.y += (Math.random() - 0.5) * weapon.spread * 0.01;
  direction.normalize();

  raycaster.set(camera.position, direction);
  const hits = raycaster.intersectObjects(enemies.map(e => e.mesh), true);

  if (hits.length > 0) {
      const hitObj = hits[0].object;
      // Traverse up to find enemy owner
      let targetEnemy = null;
      enemies.forEach(e => {
          e.mesh.traverse(child => { if(child === hitObj) targetEnemy = e; });
      });

      if (targetEnemy) {
        targetEnemy.takeDamage(weapon.damage);
        playEnemyHitSound();
        if (!targetEnemy.isAlive()) handleKill(targetEnemy);
      }
  } else {
      // Hit terrain?
      const terrainHit = raycaster.intersectObject(scene.children.find(c => c.geometry && c.geometry.type === 'PlaneGeometry'));
      // Note: simplified terrain hit check
  }
}

function handleKill(enemy) {
    gameState.kills++;
    gameState.score += 100;
    addKillFeed(`KILLED ${enemy.type.toUpperCase()}`);
}

function reload() {
  const weapon = weapons[currentWeapon];
  const needed = weapon.magSize - weapon.mag;
  if(needed <= 0) return;
  const canLoad = Math.min(needed, weapon.totalAmmo);
  weapon.mag += canLoad;
  weapon.totalAmmo -= canLoad;
  showStatus(`Reloaded ${weapon.name}`);
  // Reload Animation
  gunModel.rotation.x = -1; 
  setTimeout(()=> gunModel.rotation.x = 0, 500);
}

function switchWeapon(idx) {
  if (idx >= 0 && idx < weapons.length) {
    currentWeapon = idx;
    createGunModel(weapons[idx]);
    showStatus(`Switched to ${weapons[idx].name}`);
  }
}

/* =============== INTERACTABLES =============== */
class Chest {
    constructor(x, z) {
        this.pos = new THREE.Vector3(x, getTerrainHeight(x, z) + 0.5, z);
        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({color: 0xffaa00}));
        this.mesh.position.copy(this.pos);
        scene.add(this.mesh);
        this.opened = false;
    }
    update(playerPos) {
        this.mesh.rotation.y += 0.02;
    }
    open() {
        if(this.opened) return;
        this.opened = true;
        scene.remove(this.mesh);
        // Give random weapon
        const keys = Object.keys(weaponTypes);
        const rnd = keys[Math.floor(Math.random() * keys.length)];
        weapons.push({ ...weaponTypes[rnd], mag: weaponTypes[rnd].magSize, totalAmmo: 100 });
        showStatus("Found " + weaponTypes[rnd].name);
    }
}
const chests = [];
for(let i=0; i<10; i++) chests.push(new Chest((Math.random()-0.5)*500, (Math.random()-0.5)*500));

/* =============== INPUT =============== */
const keys = {};
addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key === 'Escape') {
    if (gameState.paused) closeEscMenu();
    else openEscMenu();
  }
  if (e.key.toLowerCase() === 'r') reload();
  if (e.key === '1') switchWeapon(0);
  if (e.key === '2') switchWeapon(1);
  if (e.key === '3') switchWeapon(2);
  
  if (e.key.toLowerCase() === 'e') {
      // Check chests
      chests.forEach(c => {
          if(c.pos.distanceTo(player.pos) < 5) c.open();
      });
  }
});
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

let mouseDown = false;
addEventListener('mousedown', () => { 
    if(gameState.paused) return;
    mouseDown = true; 
    renderer.domElement.requestPointerLock(); 
});
addEventListener('mouseup', () => mouseDown = false);
addEventListener('mousemove', e => {
  if(gameState.paused) return;
  const deltaX = e.movementX || 0;
  const deltaY = e.movementY || 0;
  cameraState.targetYaw -= deltaX * CONFIG.sensitivity;
  cameraState.targetPitch -= deltaY * CONFIG.sensitivity;
  cameraState.targetPitch = Math.max(-1.5, Math.min(1.5, cameraState.targetPitch));
});

/* =============== MAIN LOOP =============== */
let lastTime = Date.now();

function tick() {
  const now = Date.now();
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;

  if (!gameState.paused) {
    gameState.gameTime += dt * 0.1;

    // Movement Physics
    const moveDir = new THREE.Vector3();
    let speed = keys['shift'] ? CONFIG.sprintSpeed : CONFIG.walkSpeed;
    if (keys['control']) speed = CONFIG.crouchSpeed;

    if (keys['w']) moveDir.z -= 1;
    if (keys['s']) moveDir.z += 1;
    if (keys['a']) moveDir.x -= 1;
    if (keys['d']) moveDir.x += 1;

    if (moveDir.length() > 0) {
      moveDir.normalize();
      const worldDir = moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraState.yaw);
      player.vel.x = worldDir.x * speed;
      player.vel.z = worldDir.z * speed;
    } else {
      player.vel.x *= CONFIG.friction;
      player.vel.z *= CONFIG.friction;
    }

    player.vel.y += CONFIG.gravity * dt;
    if (keys[' '] && player.isGrounded) {
      player.vel.y = CONFIG.jumpPower;
      player.isGrounded = false;
    }

    player.pos.add(player.vel.clone().multiplyScalar(dt));

    const groundHeight = getTerrainHeight(player.pos.x, player.pos.z);
    if (player.pos.y <= groundHeight + 1.8) {
      player.pos.y = groundHeight + 1.8;
      player.vel.y = 0;
      player.isGrounded = true;
    } else {
      player.isGrounded = false;
    }

    camera.position.lerp(player.pos, 0.5);

    // Camera Rotation Smoothing
    cameraState.pitch += (cameraState.targetPitch - cameraState.pitch) * 0.2;
    cameraState.yaw += (cameraState.targetYaw - cameraState.yaw) * 0.2;
    camera.rotation.order = 'YXZ';
    camera.rotation.y = cameraState.yaw;
    camera.rotation.x = cameraState.pitch;

    if (mouseDown) shoot();

    // Game Logic
    enemies.forEach(e => e.update(player.pos, dt));
    enemies = enemies.filter(e => {
        if(!e.isAlive()) { scene.remove(e.mesh); return false; }
        return true;
    });
    
    chests.forEach(c => c.update(player.pos));
    updateParticles(dt);

    if (enemies.length === 0) spawnWave();
    
    // HUD Update
    document.getElementById('health').innerText = Math.floor(gameState.health);
    document.getElementById('magAmmo').innerText = weapons[currentWeapon].mag;
    document.getElementById('weaponName').innerText = weapons[currentWeapon].name;
    document.getElementById('kills').innerText = gameState.kills;
    document.getElementById('scoreDisplay').innerText = gameState.score;
  }

  updateGunView(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}

// UI Helpers
function showStatus(msg) {
    const el = document.getElementById('status');
    el.innerText = msg;
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 1500);
}
function addKillFeed(msg) {
    const el = document.getElementById('killFeed');
    const div = document.createElement('div');
    div.className = 'killFeedItem';
    div.innerText = msg;
    el.appendChild(div);
    setTimeout(() => div.remove(), 3000);
}
function openEscMenu() {
    gameState.paused = true;
    document.exitPointerLock();
    document.getElementById('escMenu').classList.add('visible');
}
function closeEscMenu() {
    gameState.paused = false;
    document.getElementById('escMenu').classList.remove('visible');
    renderer.domElement.requestPointerLock();
}

// Init
spawnSafeZones();
spawnWave();
createGunModel(weapons[0]);
tick();

// Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>